import {
  __commonJS
} from "./chunk-TWLJ45QX.js";

// node_modules/holderjs/holder.js
var require_holder = __commonJS({
  "node_modules/holderjs/holder.js"(exports, module) {
    (function(window2) {
      if (!window2.document)
        return;
      var document2 = window2.document;
      if (!document2.querySelectorAll) {
        document2.querySelectorAll = function(selectors) {
          var style = document2.createElement("style"), elements = [], element;
          document2.documentElement.firstChild.appendChild(style);
          document2._qsa = [];
          style.styleSheet.cssText = selectors + "{x-qsa:expression(document._qsa && document._qsa.push(this))}";
          window2.scrollBy(0, 0);
          style.parentNode.removeChild(style);
          while (document2._qsa.length) {
            element = document2._qsa.shift();
            element.style.removeAttribute("x-qsa");
            elements.push(element);
          }
          document2._qsa = null;
          return elements;
        };
      }
      if (!document2.querySelector) {
        document2.querySelector = function(selectors) {
          var elements = document2.querySelectorAll(selectors);
          return elements.length ? elements[0] : null;
        };
      }
      if (!document2.getElementsByClassName) {
        document2.getElementsByClassName = function(classNames) {
          classNames = String(classNames).replace(/^|\s+/g, ".");
          return document2.querySelectorAll(classNames);
        };
      }
      if (!Object.keys) {
        Object.keys = function(o) {
          if (o !== Object(o)) {
            throw TypeError("Object.keys called on non-object");
          }
          var ret = [], p;
          for (p in o) {
            if (Object.prototype.hasOwnProperty.call(o, p)) {
              ret.push(p);
            }
          }
          return ret;
        };
      }
      if (!Array.prototype.forEach) {
        Array.prototype.forEach = function(fun) {
          if (this === void 0 || this === null) {
            throw TypeError();
          }
          var t = Object(this);
          var len = t.length >>> 0;
          if (typeof fun !== "function") {
            throw TypeError();
          }
          var thisp = arguments[1], i;
          for (i = 0; i < len; i++) {
            if (i in t) {
              fun.call(thisp, t[i], i, t);
            }
          }
        };
      }
      (function(global) {
        var B64_ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        global.atob = global.atob || function(input) {
          input = String(input);
          var position = 0, output = [], buffer = 0, bits = 0, n;
          input = input.replace(/\s/g, "");
          if (input.length % 4 === 0) {
            input = input.replace(/=+$/, "");
          }
          if (input.length % 4 === 1) {
            throw Error("InvalidCharacterError");
          }
          if (/[^+/0-9A-Za-z]/.test(input)) {
            throw Error("InvalidCharacterError");
          }
          while (position < input.length) {
            n = B64_ALPHABET.indexOf(input.charAt(position));
            buffer = buffer << 6 | n;
            bits += 6;
            if (bits === 24) {
              output.push(String.fromCharCode(buffer >> 16 & 255));
              output.push(String.fromCharCode(buffer >> 8 & 255));
              output.push(String.fromCharCode(buffer & 255));
              bits = 0;
              buffer = 0;
            }
            position += 1;
          }
          if (bits === 12) {
            buffer = buffer >> 4;
            output.push(String.fromCharCode(buffer & 255));
          } else if (bits === 18) {
            buffer = buffer >> 2;
            output.push(String.fromCharCode(buffer >> 8 & 255));
            output.push(String.fromCharCode(buffer & 255));
          }
          return output.join("");
        };
        global.btoa = global.btoa || function(input) {
          input = String(input);
          var position = 0, out = [], o1, o2, o3, e1, e2, e3, e4;
          if (/[^\x00-\xFF]/.test(input)) {
            throw Error("InvalidCharacterError");
          }
          while (position < input.length) {
            o1 = input.charCodeAt(position++);
            o2 = input.charCodeAt(position++);
            o3 = input.charCodeAt(position++);
            e1 = o1 >> 2;
            e2 = (o1 & 3) << 4 | o2 >> 4;
            e3 = (o2 & 15) << 2 | o3 >> 6;
            e4 = o3 & 63;
            if (position === input.length + 2) {
              e3 = 64;
              e4 = 64;
            } else if (position === input.length + 1) {
              e4 = 64;
            }
            out.push(
              B64_ALPHABET.charAt(e1),
              B64_ALPHABET.charAt(e2),
              B64_ALPHABET.charAt(e3),
              B64_ALPHABET.charAt(e4)
            );
          }
          return out.join("");
        };
      })(window2);
      if (!Object.prototype.hasOwnProperty) {
        Object.prototype.hasOwnProperty = function(prop) {
          var proto = this.__proto__ || this.constructor.prototype;
          return prop in this && (!(prop in proto) || proto[prop] !== this[prop]);
        };
      }
      (function() {
        if ("performance" in window2 === false) {
          window2.performance = {};
        }
        Date.now = Date.now || function() {
          return new Date().getTime();
        };
        if ("now" in window2.performance === false) {
          var nowOffset = Date.now();
          if (performance.timing && performance.timing.navigationStart) {
            nowOffset = performance.timing.navigationStart;
          }
          window2.performance.now = function now() {
            return Date.now() - nowOffset;
          };
        }
      })();
      if (!window2.requestAnimationFrame) {
        if (window2.webkitRequestAnimationFrame && window2.webkitCancelAnimationFrame) {
          (function(global) {
            global.requestAnimationFrame = function(callback) {
              return webkitRequestAnimationFrame(function() {
                callback(global.performance.now());
              });
            };
            global.cancelAnimationFrame = global.webkitCancelAnimationFrame;
          })(window2);
        } else if (window2.mozRequestAnimationFrame && window2.mozCancelAnimationFrame) {
          (function(global) {
            global.requestAnimationFrame = function(callback) {
              return mozRequestAnimationFrame(function() {
                callback(global.performance.now());
              });
            };
            global.cancelAnimationFrame = global.mozCancelAnimationFrame;
          })(window2);
        } else {
          (function(global) {
            global.requestAnimationFrame = function(callback) {
              return global.setTimeout(callback, 1e3 / 60);
            };
            global.cancelAnimationFrame = global.clearTimeout;
          })(window2);
        }
      }
    })(exports);
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports === "object")
        exports["Holder"] = factory();
      else
        root["Holder"] = factory();
    })(exports, function() {
      return function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
          if (installedModules[moduleId])
            return installedModules[moduleId].exports;
          var module2 = installedModules[moduleId] = {
            exports: {},
            id: moduleId,
            loaded: false
          };
          modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
          module2.loaded = true;
          return module2.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.p = "";
        return __webpack_require__(0);
      }([
        function(module2, exports2, __webpack_require__) {
          module2.exports = __webpack_require__(1);
        },
        function(module2, exports2, __webpack_require__) {
          (function(global) {
            var onDomReady = __webpack_require__(2);
            var querystring = __webpack_require__(3);
            var SceneGraph = __webpack_require__(6);
            var utils = __webpack_require__(7);
            var SVG = __webpack_require__(8);
            var DOM = __webpack_require__(9);
            var Color = __webpack_require__(10);
            var constants = __webpack_require__(11);
            var svgRenderer = __webpack_require__(12);
            var sgCanvasRenderer = __webpack_require__(27);
            var extend = utils.extend;
            var dimensionCheck = utils.dimensionCheck;
            var SVG_NS = constants.svg_ns;
            var Holder2 = {
              version: constants.version,
              addTheme: function(name, theme) {
                name != null && theme != null && (App.settings.themes[name] = theme);
                delete App.vars.cache.themeKeys;
                return this;
              },
              addImage: function(src, el) {
                var nodes = DOM.getNodeArray(el);
                nodes.forEach(function(node) {
                  var img = DOM.newEl("img");
                  var domProps = {};
                  domProps[App.setup.dataAttr] = src;
                  DOM.setAttr(img, domProps);
                  node.appendChild(img);
                });
                return this;
              },
              setResizeUpdate: function(el, value) {
                if (el.holderData) {
                  el.holderData.resizeUpdate = !!value;
                  if (el.holderData.resizeUpdate) {
                    updateResizableElements(el);
                  }
                }
              },
              run: function(userOptions) {
                userOptions = userOptions || {};
                var engineSettings = {};
                var options = extend(App.settings, userOptions);
                App.vars.preempted = true;
                App.vars.dataAttr = options.dataAttr || App.setup.dataAttr;
                engineSettings.renderer = options.renderer ? options.renderer : App.setup.renderer;
                if (App.setup.renderers.join(",").indexOf(engineSettings.renderer) === -1) {
                  engineSettings.renderer = App.setup.supportsSVG ? "svg" : App.setup.supportsCanvas ? "canvas" : "html";
                }
                var images = DOM.getNodeArray(options.images);
                var bgnodes = DOM.getNodeArray(options.bgnodes);
                var stylenodes = DOM.getNodeArray(options.stylenodes);
                var objects = DOM.getNodeArray(options.objects);
                engineSettings.stylesheets = [];
                engineSettings.svgXMLStylesheet = true;
                engineSettings.noFontFallback = !!options.noFontFallback;
                engineSettings.noBackgroundSize = !!options.noBackgroundSize;
                stylenodes.forEach(function(styleNode) {
                  if (styleNode.attributes.rel && styleNode.attributes.href && styleNode.attributes.rel.value == "stylesheet") {
                    var href = styleNode.attributes.href.value;
                    var proxyLink = DOM.newEl("a");
                    proxyLink.href = href;
                    var stylesheetURL = proxyLink.protocol + "//" + proxyLink.host + proxyLink.pathname + proxyLink.search;
                    engineSettings.stylesheets.push(stylesheetURL);
                  }
                });
                bgnodes.forEach(function(bgNode) {
                  if (!global.getComputedStyle)
                    return;
                  var backgroundImage = global.getComputedStyle(bgNode, null).getPropertyValue("background-image");
                  var dataBackgroundImage = bgNode.getAttribute("data-background-src");
                  var rawURL = dataBackgroundImage || backgroundImage;
                  var holderURL = null;
                  var holderString = options.domain + "/";
                  var holderStringIndex = rawURL.indexOf(holderString);
                  if (holderStringIndex === 0) {
                    holderURL = rawURL;
                  } else if (holderStringIndex === 1 && rawURL[0] === "?") {
                    holderURL = rawURL.slice(1);
                  } else {
                    var fragment = rawURL.substr(holderStringIndex).match(/([^"]*)"?\)/);
                    if (fragment !== null) {
                      holderURL = fragment[1];
                    } else if (rawURL.indexOf("url(") === 0) {
                      throw "Holder: unable to parse background URL: " + rawURL;
                    }
                  }
                  if (holderURL) {
                    var holderFlags = parseURL(holderURL, options);
                    if (holderFlags) {
                      prepareDOMElement({
                        mode: "background",
                        el: bgNode,
                        flags: holderFlags,
                        engineSettings
                      });
                    }
                  }
                });
                objects.forEach(function(object) {
                  var objectAttr = {};
                  try {
                    objectAttr.data = object.getAttribute("data");
                    objectAttr.dataSrc = object.getAttribute(App.vars.dataAttr);
                  } catch (e) {
                    objectAttr.error = e;
                  }
                  var objectHasSrcURL = objectAttr.data != null && objectAttr.data.indexOf(options.domain) === 0;
                  var objectHasDataSrcURL = objectAttr.dataSrc != null && objectAttr.dataSrc.indexOf(options.domain) === 0;
                  if (objectHasSrcURL) {
                    prepareImageElement(options, engineSettings, objectAttr.data, object);
                  } else if (objectHasDataSrcURL) {
                    prepareImageElement(options, engineSettings, objectAttr.dataSrc, object);
                  }
                });
                images.forEach(function(image) {
                  var imageAttr = {};
                  try {
                    imageAttr.src = image.getAttribute("src");
                    imageAttr.dataSrc = image.getAttribute(App.vars.dataAttr);
                    imageAttr.rendered = image.getAttribute("data-holder-rendered");
                  } catch (e) {
                    imageAttr.error = e;
                  }
                  var imageHasSrc = imageAttr.src != null;
                  var imageHasDataSrcURL = imageAttr.dataSrc != null && imageAttr.dataSrc.indexOf(options.domain) === 0;
                  var imageRendered = imageAttr.rendered != null && imageAttr.rendered == "true";
                  if (imageHasSrc) {
                    if (imageAttr.src.indexOf(options.domain) === 0) {
                      prepareImageElement(options, engineSettings, imageAttr.src, image);
                    } else if (imageHasDataSrcURL) {
                      if (imageRendered) {
                        prepareImageElement(options, engineSettings, imageAttr.dataSrc, image);
                      } else {
                        (function(src, options2, engineSettings2, dataSrc, image2) {
                          utils.imageExists(src, function(exists) {
                            if (!exists) {
                              prepareImageElement(options2, engineSettings2, dataSrc, image2);
                            }
                          });
                        })(imageAttr.src, options, engineSettings, imageAttr.dataSrc, image);
                      }
                    }
                  } else if (imageHasDataSrcURL) {
                    prepareImageElement(options, engineSettings, imageAttr.dataSrc, image);
                  }
                });
                return this;
              }
            };
            var App = {
              settings: {
                domain: "holder.js",
                images: "img",
                objects: "object",
                bgnodes: "body .holderjs",
                stylenodes: "head link.holderjs",
                themes: {
                  "gray": {
                    bg: "#EEEEEE",
                    fg: "#AAAAAA"
                  },
                  "social": {
                    bg: "#3a5a97",
                    fg: "#FFFFFF"
                  },
                  "industrial": {
                    bg: "#434A52",
                    fg: "#C2F200"
                  },
                  "sky": {
                    bg: "#0D8FDB",
                    fg: "#FFFFFF"
                  },
                  "vine": {
                    bg: "#39DBAC",
                    fg: "#1E292C"
                  },
                  "lava": {
                    bg: "#F8591A",
                    fg: "#1C2846"
                  }
                }
              },
              defaults: {
                size: 10,
                units: "pt",
                scale: 1 / 16
              }
            };
            function prepareImageElement(options, engineSettings, src, el) {
              var holderFlags = parseURL(src.substr(src.lastIndexOf(options.domain)), options);
              if (holderFlags) {
                prepareDOMElement({
                  mode: null,
                  el,
                  flags: holderFlags,
                  engineSettings
                });
              }
            }
            function parseURL(url, instanceOptions) {
              var holder = {
                theme: extend(App.settings.themes.gray, null),
                stylesheets: instanceOptions.stylesheets,
                instanceOptions
              };
              var firstQuestionMark = url.indexOf("?");
              var parts = [url];
              if (firstQuestionMark !== -1) {
                parts = [url.slice(0, firstQuestionMark), url.slice(firstQuestionMark + 1)];
              }
              var basics = parts[0].split("/");
              holder.holderURL = url;
              var dimensions = basics[1];
              var dimensionData = dimensions.match(/([\d]+p?)x([\d]+p?)/);
              if (!dimensionData)
                return false;
              holder.fluid = dimensions.indexOf("p") !== -1;
              holder.dimensions = {
                width: dimensionData[1].replace("p", "%"),
                height: dimensionData[2].replace("p", "%")
              };
              if (parts.length === 2) {
                var options = querystring.parse(parts[1]);
                if (utils.truthy(options.ratio)) {
                  holder.fluid = true;
                  var ratioWidth = parseFloat(holder.dimensions.width.replace("%", ""));
                  var ratioHeight = parseFloat(holder.dimensions.height.replace("%", ""));
                  ratioHeight = Math.floor(100 * (ratioHeight / ratioWidth));
                  ratioWidth = 100;
                  holder.dimensions.width = ratioWidth + "%";
                  holder.dimensions.height = ratioHeight + "%";
                }
                holder.auto = utils.truthy(options.auto);
                if (options.bg) {
                  holder.theme.bg = utils.parseColor(options.bg);
                }
                if (options.fg) {
                  holder.theme.fg = utils.parseColor(options.fg);
                }
                if (options.bg && !options.fg) {
                  holder.autoFg = true;
                }
                if (options.theme && Object.prototype.hasOwnProperty.call(holder.instanceOptions.themes, options.theme)) {
                  holder.theme = extend(holder.instanceOptions.themes[options.theme], null);
                }
                if (options.text) {
                  holder.text = options.text;
                }
                if (options.textmode) {
                  holder.textmode = options.textmode;
                }
                if (options.size && parseFloat(options.size)) {
                  holder.size = parseFloat(options.size);
                }
                if (options.fixedSize != null) {
                  holder.fixedSize = utils.truthy(options.fixedSize);
                }
                if (options.font) {
                  holder.font = options.font;
                }
                if (options.align) {
                  holder.align = options.align;
                }
                if (options.lineWrap) {
                  holder.lineWrap = options.lineWrap;
                }
                holder.nowrap = utils.truthy(options.nowrap);
                holder.outline = utils.truthy(options.outline);
                if (utils.truthy(options.random)) {
                  App.vars.cache.themeKeys = App.vars.cache.themeKeys || Object.keys(holder.instanceOptions.themes);
                  var _theme = App.vars.cache.themeKeys[0 | Math.random() * App.vars.cache.themeKeys.length];
                  holder.theme = extend(holder.instanceOptions.themes[_theme], null);
                }
              }
              return holder;
            }
            function prepareDOMElement(prepSettings) {
              var mode = prepSettings.mode;
              var el = prepSettings.el;
              var flags = prepSettings.flags;
              var _engineSettings = prepSettings.engineSettings;
              var dimensions = flags.dimensions, theme = flags.theme;
              var dimensionsCaption = dimensions.width + "x" + dimensions.height;
              mode = mode == null ? flags.fluid ? "fluid" : "image" : mode;
              var holderTemplateRe = /holder_([a-z]+)/g;
              var dimensionsInText = false;
              if (flags.text != null) {
                theme.text = flags.text;
                if (el.nodeName.toLowerCase() === "object") {
                  var textLines = theme.text.split("\\n");
                  for (var k = 0; k < textLines.length; k++) {
                    textLines[k] = utils.encodeHtmlEntity(textLines[k]);
                  }
                  theme.text = textLines.join("\\n");
                }
              }
              if (theme.text) {
                var holderTemplateMatches = theme.text.match(holderTemplateRe);
                if (holderTemplateMatches !== null) {
                  holderTemplateMatches.forEach(function(match) {
                    if (match === "holder_dimensions") {
                      theme.text = theme.text.replace(match, dimensionsCaption);
                    }
                  });
                }
              }
              var holderURL = flags.holderURL;
              var engineSettings = extend(_engineSettings, null);
              if (flags.font) {
                theme.font = flags.font;
                if (!engineSettings.noFontFallback && el.nodeName.toLowerCase() === "img" && App.setup.supportsCanvas && engineSettings.renderer === "svg") {
                  engineSettings = extend(engineSettings, {
                    renderer: "canvas"
                  });
                }
              }
              if (flags.font && engineSettings.renderer == "canvas") {
                engineSettings.reRender = true;
              }
              if (mode == "background") {
                if (el.getAttribute("data-background-src") == null) {
                  DOM.setAttr(el, {
                    "data-background-src": holderURL
                  });
                }
              } else {
                var domProps = {};
                domProps[App.vars.dataAttr] = holderURL;
                DOM.setAttr(el, domProps);
              }
              flags.theme = theme;
              el.holderData = {
                flags,
                engineSettings
              };
              if (mode == "image" || mode == "fluid") {
                DOM.setAttr(el, {
                  "alt": theme.text ? dimensionsInText ? theme.text : theme.text + " [" + dimensionsCaption + "]" : dimensionsCaption
                });
              }
              var renderSettings = {
                mode,
                el,
                holderSettings: {
                  dimensions,
                  theme,
                  flags
                },
                engineSettings
              };
              if (mode == "image") {
                if (!flags.auto) {
                  el.style.width = dimensions.width + "px";
                  el.style.height = dimensions.height + "px";
                }
                if (engineSettings.renderer == "html") {
                  el.style.backgroundColor = theme.bg;
                } else {
                  render(renderSettings);
                  if (flags.textmode == "exact") {
                    el.holderData.resizeUpdate = true;
                    App.vars.resizableImages.push(el);
                    updateResizableElements(el);
                  }
                }
              } else if (mode == "background" && engineSettings.renderer != "html") {
                render(renderSettings);
              } else if (mode == "fluid") {
                el.holderData.resizeUpdate = true;
                if (dimensions.height.slice(-1) == "%") {
                  el.style.height = dimensions.height;
                } else if (flags.auto == null || !flags.auto) {
                  el.style.height = dimensions.height + "px";
                }
                if (dimensions.width.slice(-1) == "%") {
                  el.style.width = dimensions.width;
                } else if (flags.auto == null || !flags.auto) {
                  el.style.width = dimensions.width + "px";
                }
                if (el.style.display == "inline" || el.style.display === "" || el.style.display == "none") {
                  el.style.display = "block";
                }
                setInitialDimensions(el);
                if (engineSettings.renderer == "html") {
                  el.style.backgroundColor = theme.bg;
                } else {
                  App.vars.resizableImages.push(el);
                  updateResizableElements(el);
                }
              }
            }
            function render(renderSettings) {
              var image = null;
              var mode = renderSettings.mode;
              var el = renderSettings.el;
              var holderSettings = renderSettings.holderSettings;
              var engineSettings = renderSettings.engineSettings;
              switch (engineSettings.renderer) {
                case "svg":
                  if (!App.setup.supportsSVG)
                    return;
                  break;
                case "canvas":
                  if (!App.setup.supportsCanvas)
                    return;
                  break;
                default:
                  return;
              }
              var scene = {
                width: holderSettings.dimensions.width,
                height: holderSettings.dimensions.height,
                theme: holderSettings.theme,
                flags: holderSettings.flags
              };
              var sceneGraph = buildSceneGraph(scene);
              function getRenderedImage() {
                var image2 = null;
                switch (engineSettings.renderer) {
                  case "canvas":
                    image2 = sgCanvasRenderer(sceneGraph, renderSettings);
                    break;
                  case "svg":
                    image2 = svgRenderer(sceneGraph, renderSettings);
                    break;
                  default:
                    throw "Holder: invalid renderer: " + engineSettings.renderer;
                }
                return image2;
              }
              image = getRenderedImage();
              if (image == null) {
                throw "Holder: couldn't render placeholder";
              }
              if (mode == "background") {
                el.style.backgroundImage = "url(" + image + ")";
                if (!engineSettings.noBackgroundSize) {
                  el.style.backgroundSize = scene.width + "px " + scene.height + "px";
                }
              } else {
                if (el.nodeName.toLowerCase() === "img") {
                  DOM.setAttr(el, {
                    "src": image
                  });
                } else if (el.nodeName.toLowerCase() === "object") {
                  DOM.setAttr(el, {
                    "data": image,
                    "type": "image/svg+xml"
                  });
                }
                if (engineSettings.reRender) {
                  global.setTimeout(function() {
                    var image2 = getRenderedImage();
                    if (image2 == null) {
                      throw "Holder: couldn't render placeholder";
                    }
                    if (el.nodeName.toLowerCase() === "img") {
                      DOM.setAttr(el, {
                        "src": image2
                      });
                    } else if (el.nodeName.toLowerCase() === "object") {
                      DOM.setAttr(el, {
                        "data": image2,
                        "type": "image/svg+xml"
                      });
                    }
                  }, 150);
                }
              }
              DOM.setAttr(el, {
                "data-holder-rendered": true
              });
            }
            function buildSceneGraph(scene) {
              var fontSize = App.defaults.size;
              var fixedSize = scene.flags.fixedSize != null ? scene.flags.fixedSize : scene.theme.fixedSize;
              if (parseFloat(scene.theme.size)) {
                fontSize = scene.theme.size;
              } else if (parseFloat(scene.flags.size)) {
                fontSize = scene.flags.size;
              }
              scene.font = {
                family: scene.theme.font ? scene.theme.font : "Arial, Helvetica, Open Sans, sans-serif",
                size: fixedSize ? fontSize : textSize(scene.width, scene.height, fontSize, App.defaults.scale),
                units: scene.theme.units ? scene.theme.units : App.defaults.units,
                weight: scene.theme.fontweight ? scene.theme.fontweight : "bold"
              };
              scene.text = scene.theme.text || Math.floor(scene.width) + "x" + Math.floor(scene.height);
              scene.noWrap = scene.theme.nowrap || scene.flags.nowrap;
              scene.align = scene.theme.align || scene.flags.align || "center";
              switch (scene.flags.textmode) {
                case "literal":
                  scene.text = scene.flags.dimensions.width + "x" + scene.flags.dimensions.height;
                  break;
                case "exact":
                  if (!scene.flags.exactDimensions)
                    break;
                  scene.text = Math.floor(scene.flags.exactDimensions.width) + "x" + Math.floor(scene.flags.exactDimensions.height);
                  break;
              }
              var lineWrap = scene.flags.lineWrap || App.setup.lineWrapRatio;
              var sceneMargin = scene.width * lineWrap;
              var maxLineWidth = sceneMargin;
              var sceneGraph = new SceneGraph({
                width: scene.width,
                height: scene.height
              });
              var Shape = sceneGraph.Shape;
              var holderBg = new Shape.Rect("holderBg", {
                fill: scene.theme.bg
              });
              holderBg.resize(scene.width, scene.height);
              sceneGraph.root.add(holderBg);
              if (scene.flags.outline) {
                var outlineColor = new Color(holderBg.properties.fill);
                outlineColor = outlineColor.lighten(outlineColor.lighterThan("7f7f7f") ? -0.1 : 0.1);
                holderBg.properties.outline = {
                  fill: outlineColor.toHex(true),
                  width: 2
                };
              }
              var holderTextColor = scene.theme.fg;
              if (scene.flags.autoFg) {
                var holderBgColor = new Color(holderBg.properties.fill);
                var lightColor = new Color("fff");
                var darkColor = new Color("000", {
                  "alpha": 0.285714
                });
                holderTextColor = holderBgColor.blendAlpha(holderBgColor.lighterThan("7f7f7f") ? darkColor : lightColor).toHex(true);
              }
              var holderTextGroup = new Shape.Group("holderTextGroup", {
                text: scene.text,
                align: scene.align,
                font: scene.font,
                fill: holderTextColor
              });
              holderTextGroup.moveTo(null, null, 1);
              sceneGraph.root.add(holderTextGroup);
              var tpdata = holderTextGroup.textPositionData = stagingRenderer(sceneGraph);
              if (!tpdata) {
                throw "Holder: staging fallback not supported yet.";
              }
              holderTextGroup.properties.leading = tpdata.boundingBox.height;
              var textNode = null;
              var line = null;
              function finalizeLine(parent, line2, width, height) {
                line2.width = width;
                line2.height = height;
                parent.width = Math.max(parent.width, line2.width);
                parent.height += line2.height;
              }
              if (tpdata.lineCount > 1) {
                var offsetX = 0;
                var offsetY = 0;
                var lineIndex = 0;
                var lineKey;
                line = new Shape.Group("line" + lineIndex);
                if (scene.align === "left" || scene.align === "right") {
                  maxLineWidth = scene.width * (1 - (1 - lineWrap) * 2);
                }
                for (var i = 0; i < tpdata.words.length; i++) {
                  var word = tpdata.words[i];
                  textNode = new Shape.Text(word.text);
                  var newline = word.text == "\\n";
                  if (!scene.noWrap && (offsetX + word.width >= maxLineWidth || newline === true)) {
                    finalizeLine(holderTextGroup, line, offsetX, holderTextGroup.properties.leading);
                    holderTextGroup.add(line);
                    offsetX = 0;
                    offsetY += holderTextGroup.properties.leading;
                    lineIndex += 1;
                    line = new Shape.Group("line" + lineIndex);
                    line.y = offsetY;
                  }
                  if (newline === true) {
                    continue;
                  }
                  textNode.moveTo(offsetX, 0);
                  offsetX += tpdata.spaceWidth + word.width;
                  line.add(textNode);
                }
                finalizeLine(holderTextGroup, line, offsetX, holderTextGroup.properties.leading);
                holderTextGroup.add(line);
                if (scene.align === "left") {
                  holderTextGroup.moveTo(scene.width - sceneMargin, null, null);
                } else if (scene.align === "right") {
                  for (lineKey in holderTextGroup.children) {
                    line = holderTextGroup.children[lineKey];
                    line.moveTo(scene.width - line.width, null, null);
                  }
                  holderTextGroup.moveTo(0 - (scene.width - sceneMargin), null, null);
                } else {
                  for (lineKey in holderTextGroup.children) {
                    line = holderTextGroup.children[lineKey];
                    line.moveTo((holderTextGroup.width - line.width) / 2, null, null);
                  }
                  holderTextGroup.moveTo((scene.width - holderTextGroup.width) / 2, null, null);
                }
                holderTextGroup.moveTo(null, (scene.height - holderTextGroup.height) / 2, null);
                if ((scene.height - holderTextGroup.height) / 2 < 0) {
                  holderTextGroup.moveTo(null, 0, null);
                }
              } else {
                textNode = new Shape.Text(scene.text);
                line = new Shape.Group("line0");
                line.add(textNode);
                holderTextGroup.add(line);
                if (scene.align === "left") {
                  holderTextGroup.moveTo(scene.width - sceneMargin, null, null);
                } else if (scene.align === "right") {
                  holderTextGroup.moveTo(0 - (scene.width - sceneMargin), null, null);
                } else {
                  holderTextGroup.moveTo((scene.width - tpdata.boundingBox.width) / 2, null, null);
                }
                holderTextGroup.moveTo(null, (scene.height - tpdata.boundingBox.height) / 2, null);
              }
              return sceneGraph;
            }
            function textSize(width, height, fontSize, scale) {
              var stageWidth = parseInt(width, 10);
              var stageHeight = parseInt(height, 10);
              var bigSide = Math.max(stageWidth, stageHeight);
              var smallSide = Math.min(stageWidth, stageHeight);
              var newHeight = 0.8 * Math.min(smallSide, bigSide * scale);
              return Math.round(Math.max(fontSize, newHeight));
            }
            function updateResizableElements(element) {
              var images;
              if (element == null || element.nodeType == null) {
                images = App.vars.resizableImages;
              } else {
                images = [element];
              }
              for (var i = 0, l = images.length; i < l; i++) {
                var el = images[i];
                if (el.holderData) {
                  var flags = el.holderData.flags;
                  var dimensions = dimensionCheck(el);
                  if (dimensions) {
                    if (!el.holderData.resizeUpdate) {
                      continue;
                    }
                    if (flags.fluid && flags.auto) {
                      var fluidConfig = el.holderData.fluidConfig;
                      switch (fluidConfig.mode) {
                        case "width":
                          dimensions.height = dimensions.width / fluidConfig.ratio;
                          break;
                        case "height":
                          dimensions.width = dimensions.height * fluidConfig.ratio;
                          break;
                      }
                    }
                    var settings = {
                      mode: "image",
                      holderSettings: {
                        dimensions,
                        theme: flags.theme,
                        flags
                      },
                      el,
                      engineSettings: el.holderData.engineSettings
                    };
                    if (flags.textmode == "exact") {
                      flags.exactDimensions = dimensions;
                      settings.holderSettings.dimensions = flags.dimensions;
                    }
                    render(settings);
                  } else {
                    setInvisible(el);
                  }
                }
              }
            }
            function setInitialDimensions(el) {
              if (el.holderData) {
                var dimensions = dimensionCheck(el);
                if (dimensions) {
                  var flags = el.holderData.flags;
                  var fluidConfig = {
                    fluidHeight: flags.dimensions.height.slice(-1) == "%",
                    fluidWidth: flags.dimensions.width.slice(-1) == "%",
                    mode: null,
                    initialDimensions: dimensions
                  };
                  if (fluidConfig.fluidWidth && !fluidConfig.fluidHeight) {
                    fluidConfig.mode = "width";
                    fluidConfig.ratio = fluidConfig.initialDimensions.width / parseFloat(flags.dimensions.height);
                  } else if (!fluidConfig.fluidWidth && fluidConfig.fluidHeight) {
                    fluidConfig.mode = "height";
                    fluidConfig.ratio = parseFloat(flags.dimensions.width) / fluidConfig.initialDimensions.height;
                  }
                  el.holderData.fluidConfig = fluidConfig;
                } else {
                  setInvisible(el);
                }
              }
            }
            function visibilityCheck() {
              var renderableImages = [];
              var keys = Object.keys(App.vars.invisibleImages);
              var el;
              keys.forEach(function(key) {
                el = App.vars.invisibleImages[key];
                if (dimensionCheck(el) && el.nodeName.toLowerCase() == "img") {
                  renderableImages.push(el);
                  delete App.vars.invisibleImages[key];
                }
              });
              if (renderableImages.length) {
                Holder2.run({
                  images: renderableImages
                });
              }
              setTimeout(function() {
                global.requestAnimationFrame(visibilityCheck);
              }, 10);
            }
            function startVisibilityCheck() {
              if (!App.vars.visibilityCheckStarted) {
                global.requestAnimationFrame(visibilityCheck);
                App.vars.visibilityCheckStarted = true;
              }
            }
            function setInvisible(el) {
              if (!el.holderData.invisibleId) {
                App.vars.invisibleId += 1;
                App.vars.invisibleImages["i" + App.vars.invisibleId] = el;
                el.holderData.invisibleId = App.vars.invisibleId;
              }
            }
            var stagingRenderer = function() {
              var svg = null, stagingText = null, stagingTextNode = null;
              return function(graph) {
                var rootNode = graph.root;
                if (App.setup.supportsSVG) {
                  var firstTimeSetup = false;
                  var tnode = function(text) {
                    return document.createTextNode(text);
                  };
                  if (svg == null || svg.parentNode !== document.body) {
                    firstTimeSetup = true;
                  }
                  svg = SVG.initSVG(svg, rootNode.properties.width, rootNode.properties.height);
                  svg.style.display = "block";
                  if (firstTimeSetup) {
                    stagingText = DOM.newEl("text", SVG_NS);
                    stagingTextNode = tnode(null);
                    DOM.setAttr(stagingText, {
                      x: 0
                    });
                    stagingText.appendChild(stagingTextNode);
                    svg.appendChild(stagingText);
                    document.body.appendChild(svg);
                    svg.style.visibility = "hidden";
                    svg.style.position = "absolute";
                    svg.style.top = "-100%";
                    svg.style.left = "-100%";
                  }
                  var holderTextGroup = rootNode.children.holderTextGroup;
                  var htgProps = holderTextGroup.properties;
                  DOM.setAttr(stagingText, {
                    "y": htgProps.font.size,
                    "style": utils.cssProps({
                      "font-weight": htgProps.font.weight,
                      "font-size": htgProps.font.size + htgProps.font.units,
                      "font-family": htgProps.font.family
                    })
                  });
                  var txt = DOM.newEl("textarea");
                  txt.innerHTML = htgProps.text;
                  stagingTextNode.nodeValue = txt.value;
                  var stagingTextBBox = stagingText.getBBox();
                  var lineCount = Math.ceil(stagingTextBBox.width / rootNode.properties.width);
                  var words = htgProps.text.split(" ");
                  var newlines = htgProps.text.match(/\\n/g);
                  lineCount += newlines == null ? 0 : newlines.length;
                  stagingTextNode.nodeValue = htgProps.text.replace(/[ ]+/g, "");
                  var computedNoSpaceLength = stagingText.getComputedTextLength();
                  var diffLength = stagingTextBBox.width - computedNoSpaceLength;
                  var spaceWidth = Math.round(diffLength / Math.max(1, words.length - 1));
                  var wordWidths = [];
                  if (lineCount > 1) {
                    stagingTextNode.nodeValue = "";
                    for (var i = 0; i < words.length; i++) {
                      if (words[i].length === 0)
                        continue;
                      stagingTextNode.nodeValue = utils.decodeHtmlEntity(words[i]);
                      var bbox = stagingText.getBBox();
                      wordWidths.push({
                        text: words[i],
                        width: bbox.width
                      });
                    }
                  }
                  svg.style.display = "none";
                  return {
                    spaceWidth,
                    lineCount,
                    boundingBox: stagingTextBBox,
                    words: wordWidths
                  };
                } else {
                  return false;
                }
              };
            }();
            function debounce(fn) {
              if (!App.vars.debounceTimer)
                fn.call(this);
              if (App.vars.debounceTimer)
                global.clearTimeout(App.vars.debounceTimer);
              App.vars.debounceTimer = global.setTimeout(function() {
                App.vars.debounceTimer = null;
                fn.call(this);
              }, App.setup.debounce);
            }
            function resizeEvent() {
              debounce(function() {
                updateResizableElements(null);
              });
            }
            for (var flag in App.flags) {
              if (!Object.prototype.hasOwnProperty.call(App.flags, flag))
                continue;
              App.flags[flag].match = function(val) {
                return val.match(this.regex);
              };
            }
            App.setup = {
              renderer: "html",
              debounce: 100,
              ratio: 1,
              supportsCanvas: false,
              supportsSVG: false,
              lineWrapRatio: 0.9,
              dataAttr: "data-src",
              renderers: ["html", "canvas", "svg"]
            };
            App.vars = {
              preempted: false,
              resizableImages: [],
              invisibleImages: {},
              invisibleId: 0,
              visibilityCheckStarted: false,
              debounceTimer: null,
              cache: {}
            };
            (function() {
              var canvas = DOM.newEl("canvas");
              if (canvas.getContext) {
                if (canvas.toDataURL("image/png").indexOf("data:image/png") != -1) {
                  App.setup.renderer = "canvas";
                  App.setup.supportsCanvas = true;
                }
              }
              if (!!document.createElementNS && !!document.createElementNS(SVG_NS, "svg").createSVGRect) {
                App.setup.renderer = "svg";
                App.setup.supportsSVG = true;
              }
            })();
            startVisibilityCheck();
            if (onDomReady) {
              onDomReady(function() {
                if (!App.vars.preempted) {
                  Holder2.run();
                }
                if (global.addEventListener) {
                  global.addEventListener("resize", resizeEvent, false);
                  global.addEventListener("orientationchange", resizeEvent, false);
                } else {
                  global.attachEvent("onresize", resizeEvent);
                }
                if (typeof global.Turbolinks == "object") {
                  global.document.addEventListener("page:change", function() {
                    Holder2.run();
                  });
                }
              });
            }
            module2.exports = Holder2;
          }).call(exports2, function() {
            return this;
          }());
        },
        function(module2, exports2) {
          function _onDomReady(win) {
            if (document.readyState == null && document.addEventListener) {
              document.addEventListener("DOMContentLoaded", function DOMContentLoaded() {
                document.removeEventListener("DOMContentLoaded", DOMContentLoaded, false);
                document.readyState = "complete";
              }, false);
              document.readyState = "loading";
            }
            var doc = win.document, docElem = doc.documentElement, LOAD = "load", FALSE = false, ONLOAD = "on" + LOAD, COMPLETE = "complete", READYSTATE = "readyState", ATTACHEVENT = "attachEvent", DETACHEVENT = "detachEvent", ADDEVENTLISTENER = "addEventListener", DOMCONTENTLOADED = "DOMContentLoaded", ONREADYSTATECHANGE = "onreadystatechange", REMOVEEVENTLISTENER = "removeEventListener", w3c = ADDEVENTLISTENER in doc, _top = FALSE, isReady = FALSE, callbacks = [];
            function ready(fn) {
              if (!isReady) {
                if (!doc.body) {
                  return defer(ready);
                }
                isReady = true;
                while (fn = callbacks.shift()) {
                  defer(fn);
                }
              }
            }
            function completed(event) {
              if (w3c || event.type === LOAD || doc[READYSTATE] === COMPLETE) {
                detach();
                ready();
              }
            }
            function detach() {
              if (w3c) {
                doc[REMOVEEVENTLISTENER](DOMCONTENTLOADED, completed, FALSE);
                win[REMOVEEVENTLISTENER](LOAD, completed, FALSE);
              } else {
                doc[DETACHEVENT](ONREADYSTATECHANGE, completed);
                win[DETACHEVENT](ONLOAD, completed);
              }
            }
            function defer(fn, wait) {
              setTimeout(fn, +wait >= 0 ? wait : 1);
            }
            if (doc[READYSTATE] === COMPLETE) {
              defer(ready);
            } else if (w3c) {
              doc[ADDEVENTLISTENER](DOMCONTENTLOADED, completed, FALSE);
              win[ADDEVENTLISTENER](LOAD, completed, FALSE);
            } else {
              doc[ATTACHEVENT](ONREADYSTATECHANGE, completed);
              win[ATTACHEVENT](ONLOAD, completed);
              try {
                _top = win.frameElement == null && docElem;
              } catch (e) {
              }
              if (_top && _top.doScroll) {
                (function doScrollCheck() {
                  if (!isReady) {
                    try {
                      _top.doScroll("left");
                    } catch (e) {
                      return defer(doScrollCheck, 50);
                    }
                    detach();
                    ready();
                  }
                })();
              }
            }
            function onDomReady(fn) {
              isReady ? defer(fn) : callbacks.push(fn);
            }
            onDomReady.version = "1.4.0";
            onDomReady.isReady = function() {
              return isReady;
            };
            return onDomReady;
          }
          module2.exports = typeof window !== "undefined" && _onDomReady(window);
        },
        function(module2, exports2, __webpack_require__) {
          var encode = encodeURIComponent;
          var decode = decodeURIComponent;
          var trim = __webpack_require__(4);
          var type = __webpack_require__(5);
          var arrayRegex = /(\w+)\[(\d+)\]/;
          var objectRegex = /\w+\.\w+/;
          exports2.parse = function(str) {
            if ("string" !== typeof str)
              return {};
            str = trim(str);
            if ("" === str)
              return {};
            if ("?" === str.charAt(0))
              str = str.slice(1);
            var obj = {};
            var pairs = str.split("&");
            for (var i = 0; i < pairs.length; i++) {
              var parts = pairs[i].split("=");
              var key = decode(parts[0]);
              var m, ctx, prop;
              if (m = arrayRegex.exec(key)) {
                obj[m[1]] = obj[m[1]] || [];
                obj[m[1]][m[2]] = decode(parts[1]);
                continue;
              }
              if (m = objectRegex.test(key)) {
                m = key.split(".");
                ctx = obj;
                while (m.length) {
                  prop = m.shift();
                  if (!prop.length)
                    continue;
                  if (!ctx[prop]) {
                    ctx[prop] = {};
                  } else if (ctx[prop] && typeof ctx[prop] !== "object") {
                    break;
                  }
                  if (!m.length) {
                    ctx[prop] = decode(parts[1]);
                  }
                  ctx = ctx[prop];
                }
                continue;
              }
              obj[parts[0]] = null == parts[1] ? "" : decode(parts[1]);
            }
            return obj;
          };
          exports2.stringify = function(obj) {
            if (!obj)
              return "";
            var pairs = [];
            for (var key in obj) {
              var value = obj[key];
              if ("array" == type(value)) {
                for (var i = 0; i < value.length; ++i) {
                  pairs.push(encode(key + "[" + i + "]") + "=" + encode(value[i]));
                }
                continue;
              }
              pairs.push(encode(key) + "=" + encode(obj[key]));
            }
            return pairs.join("&");
          };
        },
        function(module2, exports2) {
          exports2 = module2.exports = trim;
          function trim(str) {
            return str.replace(/^\s*|\s*$/g, "");
          }
          exports2.left = function(str) {
            return str.replace(/^\s*/, "");
          };
          exports2.right = function(str) {
            return str.replace(/\s*$/, "");
          };
        },
        function(module2, exports2) {
          var toString = Object.prototype.toString;
          module2.exports = function(val) {
            switch (toString.call(val)) {
              case "[object Date]":
                return "date";
              case "[object RegExp]":
                return "regexp";
              case "[object Arguments]":
                return "arguments";
              case "[object Array]":
                return "array";
              case "[object Error]":
                return "error";
            }
            if (val === null)
              return "null";
            if (val === void 0)
              return "undefined";
            if (val !== val)
              return "nan";
            if (val && val.nodeType === 1)
              return "element";
            val = val.valueOf ? val.valueOf() : Object.prototype.valueOf.apply(val);
            return typeof val;
          };
        },
        function(module2, exports2) {
          var SceneGraph = function(sceneProperties) {
            var nodeCount = 1;
            function merge(parent, child) {
              for (var prop in child) {
                parent[prop] = child[prop];
              }
              return parent;
            }
            var SceneNode = function(name) {
              nodeCount++;
              this.parent = null;
              this.children = {};
              this.id = nodeCount;
              this.name = "n" + nodeCount;
              if (typeof name !== "undefined") {
                this.name = name;
              }
              this.x = this.y = this.z = 0;
              this.width = this.height = 0;
            };
            SceneNode.prototype.resize = function(width, height) {
              if (width != null) {
                this.width = width;
              }
              if (height != null) {
                this.height = height;
              }
            };
            SceneNode.prototype.moveTo = function(x, y, z) {
              this.x = x != null ? x : this.x;
              this.y = y != null ? y : this.y;
              this.z = z != null ? z : this.z;
            };
            SceneNode.prototype.add = function(child) {
              var name = child.name;
              if (typeof this.children[name] === "undefined") {
                this.children[name] = child;
                child.parent = this;
              } else {
                throw "SceneGraph: child already exists: " + name;
              }
            };
            var RootNode = function() {
              SceneNode.call(this, "root");
              this.properties = sceneProperties;
            };
            RootNode.prototype = new SceneNode();
            var Shape = function(name, props) {
              SceneNode.call(this, name);
              this.properties = {
                "fill": "#000000"
              };
              if (typeof props !== "undefined") {
                merge(this.properties, props);
              } else if (typeof name !== "undefined" && typeof name !== "string") {
                throw "SceneGraph: invalid node name";
              }
            };
            Shape.prototype = new SceneNode();
            var Group = function() {
              Shape.apply(this, arguments);
              this.type = "group";
            };
            Group.prototype = new Shape();
            var Rect = function() {
              Shape.apply(this, arguments);
              this.type = "rect";
            };
            Rect.prototype = new Shape();
            var Text = function(text) {
              Shape.call(this);
              this.type = "text";
              this.properties.text = text;
            };
            Text.prototype = new Shape();
            var root = new RootNode();
            this.Shape = {
              "Rect": Rect,
              "Text": Text,
              "Group": Group
            };
            this.root = root;
            return this;
          };
          module2.exports = SceneGraph;
        },
        function(module2, exports2) {
          (function(global) {
            exports2.extend = function(a, b) {
              var c = {};
              for (var x in a) {
                if (Object.prototype.hasOwnProperty.call(a, x)) {
                  c[x] = a[x];
                }
              }
              if (b != null) {
                for (var y in b) {
                  if (Object.prototype.hasOwnProperty.call(b, y)) {
                    c[y] = b[y];
                  }
                }
              }
              return c;
            };
            exports2.cssProps = function(props) {
              var ret = [];
              for (var p in props) {
                if (Object.prototype.hasOwnProperty.call(props, p)) {
                  ret.push(p + ":" + props[p]);
                }
              }
              return ret.join(";");
            };
            exports2.encodeHtmlEntity = function(str) {
              var buf = [];
              var charCode = 0;
              for (var i = str.length - 1; i >= 0; i--) {
                charCode = str.charCodeAt(i);
                if (charCode > 128) {
                  buf.unshift(["&#", charCode, ";"].join(""));
                } else {
                  buf.unshift(str[i]);
                }
              }
              return buf.join("");
            };
            exports2.imageExists = function(src, callback) {
              var image = new Image();
              image.onerror = function() {
                callback.call(this, false);
              };
              image.onload = function() {
                callback.call(this, true);
              };
              image.src = src;
            };
            exports2.decodeHtmlEntity = function(str) {
              return str.replace(/&#(\d+);/g, function(match, dec) {
                return String.fromCharCode(dec);
              });
            };
            exports2.dimensionCheck = function(el) {
              var dimensions = {
                height: el.clientHeight,
                width: el.clientWidth
              };
              if (dimensions.height && dimensions.width) {
                return dimensions;
              } else {
                return false;
              }
            };
            exports2.truthy = function(val) {
              if (typeof val === "string") {
                return val === "true" || val === "yes" || val === "1" || val === "on" || val === "\u2713";
              }
              return !!val;
            };
            exports2.parseColor = function(val) {
              var hexre = /(^(?:#?)[0-9a-f]{6}$)|(^(?:#?)[0-9a-f]{3}$)/i;
              var rgbre = /^rgb\((\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)$/;
              var rgbare = /^rgba\((\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(0*\.\d{1,}|1)\)$/;
              var match = val.match(hexre);
              var retval;
              if (match !== null) {
                retval = match[1] || match[2];
                if (retval[0] !== "#") {
                  return "#" + retval;
                } else {
                  return retval;
                }
              }
              match = val.match(rgbre);
              if (match !== null) {
                retval = "rgb(" + match.slice(1).join(",") + ")";
                return retval;
              }
              match = val.match(rgbare);
              if (match !== null) {
                var normalizeAlpha = function(a) {
                  return "0." + a.split(".")[1];
                };
                var fixedMatch = match.slice(1).map(function(e, i) {
                  return i === 3 ? normalizeAlpha(e) : e;
                });
                retval = "rgba(" + fixedMatch.join(",") + ")";
                return retval;
              }
              return null;
            };
            exports2.canvasRatio = function() {
              var devicePixelRatio = 1;
              var backingStoreRatio = 1;
              if (global.document) {
                var canvas = global.document.createElement("canvas");
                if (canvas.getContext) {
                  var ctx = canvas.getContext("2d");
                  devicePixelRatio = global.devicePixelRatio || 1;
                  backingStoreRatio = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;
                }
              }
              return devicePixelRatio / backingStoreRatio;
            };
          }).call(exports2, function() {
            return this;
          }());
        },
        function(module2, exports2, __webpack_require__) {
          (function(global) {
            var DOM = __webpack_require__(9);
            var SVG_NS = "http://www.w3.org/2000/svg";
            var NODE_TYPE_COMMENT = 8;
            exports2.initSVG = function(svg, width, height) {
              var defs, style, initialize = false;
              if (svg && svg.querySelector) {
                style = svg.querySelector("style");
                if (style === null) {
                  initialize = true;
                }
              } else {
                svg = DOM.newEl("svg", SVG_NS);
                initialize = true;
              }
              if (initialize) {
                defs = DOM.newEl("defs", SVG_NS);
                style = DOM.newEl("style", SVG_NS);
                DOM.setAttr(style, {
                  "type": "text/css"
                });
                defs.appendChild(style);
                svg.appendChild(defs);
              }
              if (svg.webkitMatchesSelector) {
                svg.setAttribute("xmlns", SVG_NS);
              }
              for (var i = 0; i < svg.childNodes.length; i++) {
                if (svg.childNodes[i].nodeType === NODE_TYPE_COMMENT) {
                  svg.removeChild(svg.childNodes[i]);
                }
              }
              while (style.childNodes.length) {
                style.removeChild(style.childNodes[0]);
              }
              DOM.setAttr(svg, {
                "width": width,
                "height": height,
                "viewBox": "0 0 " + width + " " + height,
                "preserveAspectRatio": "none"
              });
              return svg;
            };
            exports2.svgStringToDataURI = function() {
              var rawPrefix = "data:image/svg+xml;charset=UTF-8,";
              var base64Prefix = "data:image/svg+xml;charset=UTF-8;base64,";
              return function(svgString, base64) {
                if (base64) {
                  return base64Prefix + btoa(global.unescape(encodeURIComponent(svgString)));
                } else {
                  return rawPrefix + encodeURIComponent(svgString);
                }
              };
            }();
            exports2.serializeSVG = function(svg, engineSettings) {
              if (!global.XMLSerializer)
                return;
              var serializer = new XMLSerializer();
              var svgCSS = "";
              var stylesheets = engineSettings.stylesheets;
              if (engineSettings.svgXMLStylesheet) {
                var xml = DOM.createXML();
                for (var i = stylesheets.length - 1; i >= 0; i--) {
                  var csspi = xml.createProcessingInstruction("xml-stylesheet", 'href="' + stylesheets[i] + '" rel="stylesheet"');
                  xml.insertBefore(csspi, xml.firstChild);
                }
                xml.removeChild(xml.documentElement);
                svgCSS = serializer.serializeToString(xml);
              }
              var svgText = serializer.serializeToString(svg);
              svgText = svgText.replace(/&amp;(#[0-9]{2,};)/g, "&$1");
              return svgCSS + svgText;
            };
          }).call(exports2, function() {
            return this;
          }());
        },
        function(module2, exports2) {
          (function(global) {
            exports2.newEl = function(tag, namespace) {
              if (!global.document)
                return;
              if (namespace == null) {
                return global.document.createElement(tag);
              } else {
                return global.document.createElementNS(namespace, tag);
              }
            };
            exports2.setAttr = function(el, attrs) {
              for (var a in attrs) {
                el.setAttribute(a, attrs[a]);
              }
            };
            exports2.createXML = function() {
              if (!global.DOMParser)
                return;
              return new DOMParser().parseFromString("<xml />", "application/xml");
            };
            exports2.getNodeArray = function(val) {
              var retval = null;
              if (typeof val == "string") {
                retval = document.querySelectorAll(val);
              } else if (global.NodeList && val instanceof global.NodeList) {
                retval = val;
              } else if (global.Node && val instanceof global.Node) {
                retval = [val];
              } else if (global.HTMLCollection && val instanceof global.HTMLCollection) {
                retval = val;
              } else if (val instanceof Array) {
                retval = val;
              } else if (val === null) {
                retval = [];
              }
              retval = Array.prototype.slice.call(retval);
              return retval;
            };
          }).call(exports2, function() {
            return this;
          }());
        },
        function(module2, exports2) {
          var Color = function(color, options) {
            if (typeof color !== "string")
              return;
            this.original = color;
            if (color.charAt(0) === "#") {
              color = color.slice(1);
            }
            if (/[^a-f0-9]+/i.test(color))
              return;
            if (color.length === 3) {
              color = color.replace(/./g, "$&$&");
            }
            if (color.length !== 6)
              return;
            this.alpha = 1;
            if (options && options.alpha) {
              this.alpha = options.alpha;
            }
            this.set(parseInt(color, 16));
          };
          Color.rgb2hex = function(r, g, b) {
            function format(decimal) {
              var hex = (decimal | 0).toString(16);
              if (decimal < 16) {
                hex = "0" + hex;
              }
              return hex;
            }
            return [r, g, b].map(format).join("");
          };
          Color.hsl2rgb = function(h, s, l) {
            var H = h / 60;
            var C = (1 - Math.abs(2 * l - 1)) * s;
            var X = C * (1 - Math.abs(parseInt(H) % 2 - 1));
            var m = l - C / 2;
            var r = 0, g = 0, b = 0;
            if (H >= 0 && H < 1) {
              r = C;
              g = X;
            } else if (H >= 1 && H < 2) {
              r = X;
              g = C;
            } else if (H >= 2 && H < 3) {
              g = C;
              b = X;
            } else if (H >= 3 && H < 4) {
              g = X;
              b = C;
            } else if (H >= 4 && H < 5) {
              r = X;
              b = C;
            } else if (H >= 5 && H < 6) {
              r = C;
              b = X;
            }
            r += m;
            g += m;
            b += m;
            r = parseInt(r * 255);
            g = parseInt(g * 255);
            b = parseInt(b * 255);
            return [r, g, b];
          };
          Color.prototype.set = function(val) {
            this.raw = val;
            var r = (this.raw & 16711680) >> 16;
            var g = (this.raw & 65280) >> 8;
            var b = this.raw & 255;
            var y = 0.2126 * r + 0.7152 * g + 0.0722 * b;
            var u = -0.09991 * r - 0.33609 * g + 0.436 * b;
            var v = 0.615 * r - 0.55861 * g - 0.05639 * b;
            this.rgb = {
              r,
              g,
              b
            };
            this.yuv = {
              y,
              u,
              v
            };
            return this;
          };
          Color.prototype.lighten = function(multiplier) {
            var cm = Math.min(1, Math.max(0, Math.abs(multiplier))) * (multiplier < 0 ? -1 : 1);
            var bm = 255 * cm | 0;
            var cr = Math.min(255, Math.max(0, this.rgb.r + bm));
            var cg = Math.min(255, Math.max(0, this.rgb.g + bm));
            var cb = Math.min(255, Math.max(0, this.rgb.b + bm));
            var hex = Color.rgb2hex(cr, cg, cb);
            return new Color(hex);
          };
          Color.prototype.toHex = function(addHash) {
            return (addHash ? "#" : "") + this.raw.toString(16);
          };
          Color.prototype.lighterThan = function(color) {
            if (!(color instanceof Color)) {
              color = new Color(color);
            }
            return this.yuv.y > color.yuv.y;
          };
          Color.prototype.blendAlpha = function(color) {
            if (!(color instanceof Color)) {
              color = new Color(color);
            }
            var Ca = color;
            var Cb = this;
            var r = Ca.alpha * Ca.rgb.r + (1 - Ca.alpha) * Cb.rgb.r;
            var g = Ca.alpha * Ca.rgb.g + (1 - Ca.alpha) * Cb.rgb.g;
            var b = Ca.alpha * Ca.rgb.b + (1 - Ca.alpha) * Cb.rgb.b;
            return new Color(Color.rgb2hex(r, g, b));
          };
          module2.exports = Color;
        },
        function(module2, exports2) {
          module2.exports = {
            "version": "2.9.9",
            "svg_ns": "http://www.w3.org/2000/svg"
          };
        },
        function(module2, exports2, __webpack_require__) {
          var shaven = __webpack_require__(13).default;
          var SVG = __webpack_require__(8);
          var constants = __webpack_require__(11);
          var utils = __webpack_require__(7);
          var SVG_NS = constants.svg_ns;
          var templates = {
            "element": function(options) {
              var tag = options.tag;
              var content = options.content || "";
              delete options.tag;
              delete options.content;
              return [tag, content, options];
            }
          };
          function convertShape(shape, tag) {
            return templates.element({
              "tag": tag,
              "width": shape.width,
              "height": shape.height,
              "fill": shape.properties.fill
            });
          }
          function textCss(properties) {
            return utils.cssProps({
              "fill": properties.fill,
              "font-weight": properties.font.weight,
              "font-family": properties.font.family + ", monospace",
              "font-size": properties.font.size + properties.font.units
            });
          }
          function outlinePath(bgWidth, bgHeight, outlineWidth) {
            var outlineOffsetWidth = outlineWidth / 2;
            return [
              "M",
              outlineOffsetWidth,
              outlineOffsetWidth,
              "H",
              bgWidth - outlineOffsetWidth,
              "V",
              bgHeight - outlineOffsetWidth,
              "H",
              outlineOffsetWidth,
              "V",
              0,
              "M",
              0,
              outlineOffsetWidth,
              "L",
              bgWidth,
              bgHeight - outlineOffsetWidth,
              "M",
              0,
              bgHeight - outlineOffsetWidth,
              "L",
              bgWidth,
              outlineOffsetWidth
            ].join(" ");
          }
          module2.exports = function(sceneGraph, renderSettings) {
            var engineSettings = renderSettings.engineSettings;
            var stylesheets = engineSettings.stylesheets;
            var stylesheetXml = stylesheets.map(function(stylesheet) {
              return '<?xml-stylesheet rel="stylesheet" href="' + stylesheet + '"?>';
            }).join("\n");
            var holderId = "holder_" + Number(new Date()).toString(16);
            var root = sceneGraph.root;
            var textGroup = root.children.holderTextGroup;
            var css = "#" + holderId + " text { " + textCss(textGroup.properties) + " } ";
            textGroup.y += textGroup.textPositionData.boundingBox.height * 0.8;
            var wordTags = [];
            Object.keys(textGroup.children).forEach(function(lineKey) {
              var line = textGroup.children[lineKey];
              Object.keys(line.children).forEach(function(wordKey) {
                var word = line.children[wordKey];
                var x = textGroup.x + line.x + word.x;
                var y = textGroup.y + line.y + word.y;
                var wordTag = templates.element({
                  "tag": "text",
                  "content": word.properties.text,
                  "x": x,
                  "y": y
                });
                wordTags.push(wordTag);
              });
            });
            var text = templates.element({
              "tag": "g",
              "content": wordTags
            });
            var outline = null;
            if (root.children.holderBg.properties.outline) {
              var outlineProperties = root.children.holderBg.properties.outline;
              outline = templates.element({
                "tag": "path",
                "d": outlinePath(root.children.holderBg.width, root.children.holderBg.height, outlineProperties.width),
                "stroke-width": outlineProperties.width,
                "stroke": outlineProperties.fill,
                "fill": "none"
              });
            }
            var bg = convertShape(root.children.holderBg, "rect");
            var sceneContent = [];
            sceneContent.push(bg);
            if (outlineProperties) {
              sceneContent.push(outline);
            }
            sceneContent.push(text);
            var scene = templates.element({
              "tag": "g",
              "id": holderId,
              "content": sceneContent
            });
            var style = templates.element({
              "tag": "style",
              "content": css,
              "type": "text/css"
            });
            var defs = templates.element({
              "tag": "defs",
              "content": style
            });
            var svg = templates.element({
              "tag": "svg",
              "content": [defs, scene],
              "width": root.properties.width,
              "height": root.properties.height,
              "xmlns": SVG_NS,
              "viewBox": [0, 0, root.properties.width, root.properties.height].join(" "),
              "preserveAspectRatio": "none"
            });
            var output = String(shaven(svg));
            if (/&amp;(x)?#[0-9A-Fa-f]/.test(output[0])) {
              output = output.replace(/&amp;#/gm, "&#");
            }
            output = stylesheetXml + output;
            var svgString = SVG.svgStringToDataURI(output, renderSettings.mode === "background");
            return svgString;
          };
        },
        function(module2, exports2, __webpack_require__) {
          module2.exports = __webpack_require__(14);
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
            return typeof obj;
          } : function(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
          exports2.default = shaven;
          var _parseSugarString = __webpack_require__(15);
          var _parseSugarString2 = _interopRequireDefault(_parseSugarString);
          var _escape = __webpack_require__(16);
          var escape = _interopRequireWildcard(_escape);
          var _defaults = __webpack_require__(17);
          var _defaults2 = _interopRequireDefault(_defaults);
          var _mapAttributeValue = __webpack_require__(18);
          var _mapAttributeValue2 = _interopRequireDefault(_mapAttributeValue);
          var _assert = __webpack_require__(21);
          var _assert2 = _interopRequireDefault(_assert);
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj.default = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function shaven(arrayOrObject) {
            var isArray = Array.isArray(arrayOrObject);
            var objType = typeof arrayOrObject === "undefined" ? "undefined" : _typeof(arrayOrObject);
            if (!isArray && objType !== "object") {
              throw new Error("Argument must be either an array or an object and not " + JSON.stringify(arrayOrObject));
            }
            if (isArray && arrayOrObject.length === 0) {
              return {};
            }
            var config = {};
            var elementArray = [];
            if (Array.isArray(arrayOrObject)) {
              elementArray = arrayOrObject.slice(0);
            } else {
              elementArray = arrayOrObject.elementArray.slice(0);
              config = Object.assign(config, arrayOrObject);
              delete config.elementArray;
            }
            config = Object.assign({}, _defaults2.default, config, {
              returnObject: {
                ids: {},
                references: {}
              }
            });
            function createElement(sugarString) {
              var properties = (0, _parseSugarString2.default)(sugarString);
              var element = {
                tag: properties.tag,
                attr: {},
                children: []
              };
              if (properties.id) {
                element.attr.id = properties.id;
                (0, _assert2.default)(!config.returnObject.ids.hasOwnProperty(properties.id), 'Ids must be unique and "' + properties.id + '" is already assigned');
                config.returnObject.ids[properties.id] = element;
              }
              if (properties.class) {
                element.attr.class = properties.class;
              }
              if (properties.reference) {
                (0, _assert2.default)(!config.returnObject.ids.hasOwnProperty(properties.reference), 'References must be unique and "' + properties.id + '" is already assigned');
                config.returnObject.references[properties.reference] = element;
              }
              config.escapeHTML = properties.escapeHTML != null ? properties.escapeHTML : config.escapeHTML;
              return element;
            }
            function buildDom(elemArray) {
              if (Array.isArray(elemArray) && elemArray.length === 0) {
                return {};
              }
              var index = 1;
              var createdCallback = void 0;
              var selfClosingHTMLTags = ["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "menuitem", "meta", "param", "source", "track", "wbr"];
              var array = elemArray.slice(0);
              if (typeof array[0] === "string") {
                array[0] = createElement(array[0]);
              } else if (Array.isArray(array[0])) {
                index = 0;
              } else {
                throw new Error("First element of array must be a string, or an array and not " + JSON.stringify(array[0]));
              }
              for (; index < array.length; index++) {
                if (array[index] === false || array[index] === null) {
                  array[0] = false;
                  break;
                } else if (array[index] === void 0 || array[index] === true) {
                  continue;
                } else if (typeof array[index] === "string") {
                  if (config.escapeHTML) {
                    array[index] = escape.HTML(array[index]);
                  }
                  array[0].children.push(array[index]);
                } else if (typeof array[index] === "number") {
                  array[0].children.push(array[index]);
                } else if (Array.isArray(array[index])) {
                  if (Array.isArray(array[index][0])) {
                    array[index].reverse().forEach(function(subArray) {
                      array.splice(index + 1, 0, subArray);
                    });
                    if (index !== 0)
                      continue;
                    index++;
                  }
                  array[index] = buildDom(array[index]);
                  if (array[index][0]) {
                    array[0].children.push(array[index][0]);
                  }
                } else if (typeof array[index] === "function") {
                  createdCallback = array[index];
                } else if (_typeof(array[index]) === "object") {
                  for (var attributeKey in array[index]) {
                    if (!array[index].hasOwnProperty(attributeKey))
                      continue;
                    var attributeValue = array[index][attributeKey];
                    if (array[index].hasOwnProperty(attributeKey) && attributeValue !== null && attributeValue !== false) {
                      array[0].attr[attributeKey] = (0, _mapAttributeValue2.default)(attributeKey, attributeValue);
                    }
                  }
                } else {
                  throw new TypeError('"' + array[index] + '" is not allowed as a value');
                }
              }
              if (array[0] !== false) {
                var HTMLString = "<" + array[0].tag;
                for (var key in array[0].attr) {
                  if (array[0].attr.hasOwnProperty(key)) {
                    var _attributeValue = escape.attribute(array[0].attr[key]);
                    var value = _attributeValue;
                    if (config.quoteAttributes || /[ "'=<>]/.test(_attributeValue)) {
                      value = config.quotationMark + _attributeValue + config.quotationMark;
                    }
                    HTMLString += " " + key + "=" + value;
                  }
                }
                HTMLString += ">";
                if (!(selfClosingHTMLTags.indexOf(array[0].tag) !== -1)) {
                  array[0].children.forEach(function(child) {
                    return HTMLString += child;
                  });
                  HTMLString += "</" + array[0].tag + ">";
                }
                array[0] = HTMLString;
              }
              config.returnObject[0] = array[0];
              config.returnObject.rootElement = array[0];
              config.returnObject.toString = function() {
                return array[0];
              };
              if (createdCallback)
                createdCallback(array[0]);
              return config.returnObject;
            }
            return buildDom(elementArray);
          }
          shaven.setDefaults = function(object) {
            Object.assign(_defaults2.default, object);
            return shaven;
          };
        },
        function(module2, exports2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.default = function(sugarString) {
            var tags = sugarString.match(/^[\w-]+/);
            var properties = {
              tag: tags ? tags[0] : "div"
            };
            var ids = sugarString.match(/#([\w-]+)/);
            var classes = sugarString.match(/\.[\w-]+/g);
            var references = sugarString.match(/\$([\w-]+)/);
            if (ids)
              properties.id = ids[1];
            if (classes) {
              properties.class = classes.join(" ").replace(/\./g, "");
            }
            if (references)
              properties.reference = references[1];
            if (sugarString.endsWith("&") || sugarString.endsWith("!")) {
              properties.escapeHTML = false;
            }
            return properties;
          };
        },
        function(module2, exports2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.attribute = attribute;
          exports2.HTML = HTML;
          function attribute(string) {
            return string || string === 0 ? String(string).replace(/&/g, "&amp;").replace(/"/g, "&quot;") : "";
          }
          function HTML(string) {
            return String(string).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
          }
        },
        function(module2, exports2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.default = {
            namespace: "xhtml",
            autoNamespacing: true,
            escapeHTML: true,
            quotationMark: '"',
            quoteAttributes: true,
            convertTransformArray: true
          };
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
            return typeof obj;
          } : function(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
          var _buildTransformString = __webpack_require__(19);
          var _buildTransformString2 = _interopRequireDefault(_buildTransformString);
          var _stringifyStyleObject = __webpack_require__(20);
          var _stringifyStyleObject2 = _interopRequireDefault(_stringifyStyleObject);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          exports2.default = function(key, value) {
            if (value === void 0) {
              return "";
            }
            if (key === "style" && (typeof value === "undefined" ? "undefined" : _typeof(value)) === "object") {
              return (0, _stringifyStyleObject2.default)(value);
            }
            if (key === "transform" && Array.isArray(value)) {
              return (0, _buildTransformString2.default)(value);
            }
            return value;
          };
        },
        function(module2, exports2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.default = function(transformObjects) {
            return transformObjects.map(function(transformation) {
              var values = [];
              if (transformation.type === "rotate" && transformation.degrees) {
                values.push(transformation.degrees);
              }
              if (transformation.x)
                values.push(transformation.x);
              if (transformation.y)
                values.push(transformation.y);
              return transformation.type + "(" + values + ")";
            }).join(" ");
          };
        },
        function(module2, exports2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
            return typeof obj;
          } : function(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
          function sanitizeProperties(key, value) {
            if (value === null || value === false || value === void 0)
              return;
            if (typeof value === "string" || (typeof value === "undefined" ? "undefined" : _typeof(value)) === "object")
              return value;
            return String(value);
          }
          exports2.default = function(styleObject) {
            return JSON.stringify(styleObject, sanitizeProperties).slice(2, -2).replace(/","/g, ";").replace(/":"/g, ":").replace(/\\"/g, "'");
          };
        },
        function(module2, exports2, __webpack_require__) {
          (function(global) {
            "use strict";
            var objectAssign = __webpack_require__(22);
            function compare(a, b) {
              if (a === b) {
                return 0;
              }
              var x = a.length;
              var y = b.length;
              for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                if (a[i] !== b[i]) {
                  x = a[i];
                  y = b[i];
                  break;
                }
              }
              if (x < y) {
                return -1;
              }
              if (y < x) {
                return 1;
              }
              return 0;
            }
            function isBuffer(b) {
              if (global.Buffer && typeof global.Buffer.isBuffer === "function") {
                return global.Buffer.isBuffer(b);
              }
              return !!(b != null && b._isBuffer);
            }
            var util = __webpack_require__(23);
            var hasOwn = Object.prototype.hasOwnProperty;
            var pSlice = Array.prototype.slice;
            var functionsHaveNames = function() {
              return function foo() {
              }.name === "foo";
            }();
            function pToString(obj) {
              return Object.prototype.toString.call(obj);
            }
            function isView(arrbuf) {
              if (isBuffer(arrbuf)) {
                return false;
              }
              if (typeof global.ArrayBuffer !== "function") {
                return false;
              }
              if (typeof ArrayBuffer.isView === "function") {
                return ArrayBuffer.isView(arrbuf);
              }
              if (!arrbuf) {
                return false;
              }
              if (arrbuf instanceof DataView) {
                return true;
              }
              if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
                return true;
              }
              return false;
            }
            var assert = module2.exports = ok;
            var regex = /\s*function\s+([^\(\s]*)\s*/;
            function getName(func) {
              if (!util.isFunction(func)) {
                return;
              }
              if (functionsHaveNames) {
                return func.name;
              }
              var str = func.toString();
              var match = str.match(regex);
              return match && match[1];
            }
            assert.AssertionError = function AssertionError(options) {
              this.name = "AssertionError";
              this.actual = options.actual;
              this.expected = options.expected;
              this.operator = options.operator;
              if (options.message) {
                this.message = options.message;
                this.generatedMessage = false;
              } else {
                this.message = getMessage(this);
                this.generatedMessage = true;
              }
              var stackStartFunction = options.stackStartFunction || fail;
              if (Error.captureStackTrace) {
                Error.captureStackTrace(this, stackStartFunction);
              } else {
                var err = new Error();
                if (err.stack) {
                  var out = err.stack;
                  var fn_name = getName(stackStartFunction);
                  var idx = out.indexOf("\n" + fn_name);
                  if (idx >= 0) {
                    var next_line = out.indexOf("\n", idx + 1);
                    out = out.substring(next_line + 1);
                  }
                  this.stack = out;
                }
              }
            };
            util.inherits(assert.AssertionError, Error);
            function truncate(s, n) {
              if (typeof s === "string") {
                return s.length < n ? s : s.slice(0, n);
              } else {
                return s;
              }
            }
            function inspect(something) {
              if (functionsHaveNames || !util.isFunction(something)) {
                return util.inspect(something);
              }
              var rawname = getName(something);
              var name = rawname ? ": " + rawname : "";
              return "[Function" + name + "]";
            }
            function getMessage(self) {
              return truncate(inspect(self.actual), 128) + " " + self.operator + " " + truncate(inspect(self.expected), 128);
            }
            function fail(actual, expected, message, operator, stackStartFunction) {
              throw new assert.AssertionError({
                message,
                actual,
                expected,
                operator,
                stackStartFunction
              });
            }
            assert.fail = fail;
            function ok(value, message) {
              if (!value)
                fail(value, true, message, "==", assert.ok);
            }
            assert.ok = ok;
            assert.equal = function equal(actual, expected, message) {
              if (actual != expected)
                fail(actual, expected, message, "==", assert.equal);
            };
            assert.notEqual = function notEqual(actual, expected, message) {
              if (actual == expected) {
                fail(actual, expected, message, "!=", assert.notEqual);
              }
            };
            assert.deepEqual = function deepEqual(actual, expected, message) {
              if (!_deepEqual(actual, expected, false)) {
                fail(actual, expected, message, "deepEqual", assert.deepEqual);
              }
            };
            assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
              if (!_deepEqual(actual, expected, true)) {
                fail(actual, expected, message, "deepStrictEqual", assert.deepStrictEqual);
              }
            };
            function _deepEqual(actual, expected, strict2, memos) {
              if (actual === expected) {
                return true;
              } else if (isBuffer(actual) && isBuffer(expected)) {
                return compare(actual, expected) === 0;
              } else if (util.isDate(actual) && util.isDate(expected)) {
                return actual.getTime() === expected.getTime();
              } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
                return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
              } else if ((actual === null || typeof actual !== "object") && (expected === null || typeof expected !== "object")) {
                return strict2 ? actual === expected : actual == expected;
              } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
                return compare(
                  new Uint8Array(actual.buffer),
                  new Uint8Array(expected.buffer)
                ) === 0;
              } else if (isBuffer(actual) !== isBuffer(expected)) {
                return false;
              } else {
                memos = memos || { actual: [], expected: [] };
                var actualIndex = memos.actual.indexOf(actual);
                if (actualIndex !== -1) {
                  if (actualIndex === memos.expected.indexOf(expected)) {
                    return true;
                  }
                }
                memos.actual.push(actual);
                memos.expected.push(expected);
                return objEquiv(actual, expected, strict2, memos);
              }
            }
            function isArguments(object) {
              return Object.prototype.toString.call(object) == "[object Arguments]";
            }
            function objEquiv(a, b, strict2, actualVisitedObjects) {
              if (a === null || a === void 0 || b === null || b === void 0)
                return false;
              if (util.isPrimitive(a) || util.isPrimitive(b))
                return a === b;
              if (strict2 && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
                return false;
              var aIsArgs = isArguments(a);
              var bIsArgs = isArguments(b);
              if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs)
                return false;
              if (aIsArgs) {
                a = pSlice.call(a);
                b = pSlice.call(b);
                return _deepEqual(a, b, strict2);
              }
              var ka = objectKeys(a);
              var kb = objectKeys(b);
              var key, i;
              if (ka.length !== kb.length)
                return false;
              ka.sort();
              kb.sort();
              for (i = ka.length - 1; i >= 0; i--) {
                if (ka[i] !== kb[i])
                  return false;
              }
              for (i = ka.length - 1; i >= 0; i--) {
                key = ka[i];
                if (!_deepEqual(a[key], b[key], strict2, actualVisitedObjects))
                  return false;
              }
              return true;
            }
            assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
              if (_deepEqual(actual, expected, false)) {
                fail(actual, expected, message, "notDeepEqual", assert.notDeepEqual);
              }
            };
            assert.notDeepStrictEqual = notDeepStrictEqual;
            function notDeepStrictEqual(actual, expected, message) {
              if (_deepEqual(actual, expected, true)) {
                fail(actual, expected, message, "notDeepStrictEqual", notDeepStrictEqual);
              }
            }
            assert.strictEqual = function strictEqual(actual, expected, message) {
              if (actual !== expected) {
                fail(actual, expected, message, "===", assert.strictEqual);
              }
            };
            assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
              if (actual === expected) {
                fail(actual, expected, message, "!==", assert.notStrictEqual);
              }
            };
            function expectedException(actual, expected) {
              if (!actual || !expected) {
                return false;
              }
              if (Object.prototype.toString.call(expected) == "[object RegExp]") {
                return expected.test(actual);
              }
              try {
                if (actual instanceof expected) {
                  return true;
                }
              } catch (e) {
              }
              if (Error.isPrototypeOf(expected)) {
                return false;
              }
              return expected.call({}, actual) === true;
            }
            function _tryBlock(block) {
              var error;
              try {
                block();
              } catch (e) {
                error = e;
              }
              return error;
            }
            function _throws(shouldThrow, block, expected, message) {
              var actual;
              if (typeof block !== "function") {
                throw new TypeError('"block" argument must be a function');
              }
              if (typeof expected === "string") {
                message = expected;
                expected = null;
              }
              actual = _tryBlock(block);
              message = (expected && expected.name ? " (" + expected.name + ")." : ".") + (message ? " " + message : ".");
              if (shouldThrow && !actual) {
                fail(actual, expected, "Missing expected exception" + message);
              }
              var userProvidedMessage = typeof message === "string";
              var isUnwantedException = !shouldThrow && util.isError(actual);
              var isUnexpectedException = !shouldThrow && actual && !expected;
              if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
                fail(actual, expected, "Got unwanted exception" + message);
              }
              if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
                throw actual;
              }
            }
            assert.throws = function(block, error, message) {
              _throws(true, block, error, message);
            };
            assert.doesNotThrow = function(block, error, message) {
              _throws(false, block, error, message);
            };
            assert.ifError = function(err) {
              if (err)
                throw err;
            };
            function strict(value, message) {
              if (!value)
                fail(value, true, message, "==", strict);
            }
            assert.strict = objectAssign(strict, assert, {
              equal: assert.strictEqual,
              deepEqual: assert.deepStrictEqual,
              notEqual: assert.notStrictEqual,
              notDeepEqual: assert.notDeepStrictEqual
            });
            assert.strict.strict = assert.strict;
            var objectKeys = Object.keys || function(obj) {
              var keys = [];
              for (var key in obj) {
                if (hasOwn.call(obj, key))
                  keys.push(key);
              }
              return keys;
            };
          }).call(exports2, function() {
            return this;
          }());
        },
        function(module2, exports2) {
          "use strict";
          var getOwnPropertySymbols = Object.getOwnPropertySymbols;
          var hasOwnProperty = Object.prototype.hasOwnProperty;
          var propIsEnumerable = Object.prototype.propertyIsEnumerable;
          function toObject(val) {
            if (val === null || val === void 0) {
              throw new TypeError("Object.assign cannot be called with null or undefined");
            }
            return Object(val);
          }
          function shouldUseNative() {
            try {
              if (!Object.assign) {
                return false;
              }
              var test1 = new String("abc");
              test1[5] = "de";
              if (Object.getOwnPropertyNames(test1)[0] === "5") {
                return false;
              }
              var test2 = {};
              for (var i = 0; i < 10; i++) {
                test2["_" + String.fromCharCode(i)] = i;
              }
              var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
                return test2[n];
              });
              if (order2.join("") !== "0123456789") {
                return false;
              }
              var test3 = {};
              "abcdefghijklmnopqrst".split("").forEach(function(letter) {
                test3[letter] = letter;
              });
              if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
                return false;
              }
              return true;
            } catch (err) {
              return false;
            }
          }
          module2.exports = shouldUseNative() ? Object.assign : function(target, source) {
            var from;
            var to = toObject(target);
            var symbols;
            for (var s = 1; s < arguments.length; s++) {
              from = Object(arguments[s]);
              for (var key in from) {
                if (hasOwnProperty.call(from, key)) {
                  to[key] = from[key];
                }
              }
              if (getOwnPropertySymbols) {
                symbols = getOwnPropertySymbols(from);
                for (var i = 0; i < symbols.length; i++) {
                  if (propIsEnumerable.call(from, symbols[i])) {
                    to[symbols[i]] = from[symbols[i]];
                  }
                }
              }
            }
            return to;
          };
        },
        function(module2, exports2, __webpack_require__) {
          (function(global, process) {
            var formatRegExp = /%[sdj%]/g;
            exports2.format = function(f) {
              if (!isString(f)) {
                var objects = [];
                for (var i = 0; i < arguments.length; i++) {
                  objects.push(inspect(arguments[i]));
                }
                return objects.join(" ");
              }
              var i = 1;
              var args = arguments;
              var len = args.length;
              var str = String(f).replace(formatRegExp, function(x2) {
                if (x2 === "%%")
                  return "%";
                if (i >= len)
                  return x2;
                switch (x2) {
                  case "%s":
                    return String(args[i++]);
                  case "%d":
                    return Number(args[i++]);
                  case "%j":
                    try {
                      return JSON.stringify(args[i++]);
                    } catch (_) {
                      return "[Circular]";
                    }
                  default:
                    return x2;
                }
              });
              for (var x = args[i]; i < len; x = args[++i]) {
                if (isNull(x) || !isObject(x)) {
                  str += " " + x;
                } else {
                  str += " " + inspect(x);
                }
              }
              return str;
            };
            exports2.deprecate = function(fn, msg) {
              if (isUndefined(global.process)) {
                return function() {
                  return exports2.deprecate(fn, msg).apply(this, arguments);
                };
              }
              if (process.noDeprecation === true) {
                return fn;
              }
              var warned = false;
              function deprecated() {
                if (!warned) {
                  if (process.throwDeprecation) {
                    throw new Error(msg);
                  } else if (process.traceDeprecation) {
                    console.trace(msg);
                  } else {
                    console.error(msg);
                  }
                  warned = true;
                }
                return fn.apply(this, arguments);
              }
              return deprecated;
            };
            var debugs = {};
            var debugEnviron;
            exports2.debuglog = function(set) {
              if (isUndefined(debugEnviron))
                debugEnviron = process.env.NODE_DEBUG || "";
              set = set.toUpperCase();
              if (!debugs[set]) {
                if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
                  var pid = process.pid;
                  debugs[set] = function() {
                    var msg = exports2.format.apply(exports2, arguments);
                    console.error("%s %d: %s", set, pid, msg);
                  };
                } else {
                  debugs[set] = function() {
                  };
                }
              }
              return debugs[set];
            };
            function inspect(obj, opts) {
              var ctx = {
                seen: [],
                stylize: stylizeNoColor
              };
              if (arguments.length >= 3)
                ctx.depth = arguments[2];
              if (arguments.length >= 4)
                ctx.colors = arguments[3];
              if (isBoolean(opts)) {
                ctx.showHidden = opts;
              } else if (opts) {
                exports2._extend(ctx, opts);
              }
              if (isUndefined(ctx.showHidden))
                ctx.showHidden = false;
              if (isUndefined(ctx.depth))
                ctx.depth = 2;
              if (isUndefined(ctx.colors))
                ctx.colors = false;
              if (isUndefined(ctx.customInspect))
                ctx.customInspect = true;
              if (ctx.colors)
                ctx.stylize = stylizeWithColor;
              return formatValue(ctx, obj, ctx.depth);
            }
            exports2.inspect = inspect;
            inspect.colors = {
              "bold": [1, 22],
              "italic": [3, 23],
              "underline": [4, 24],
              "inverse": [7, 27],
              "white": [37, 39],
              "grey": [90, 39],
              "black": [30, 39],
              "blue": [34, 39],
              "cyan": [36, 39],
              "green": [32, 39],
              "magenta": [35, 39],
              "red": [31, 39],
              "yellow": [33, 39]
            };
            inspect.styles = {
              "special": "cyan",
              "number": "yellow",
              "boolean": "yellow",
              "undefined": "grey",
              "null": "bold",
              "string": "green",
              "date": "magenta",
              "regexp": "red"
            };
            function stylizeWithColor(str, styleType) {
              var style = inspect.styles[styleType];
              if (style) {
                return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
              } else {
                return str;
              }
            }
            function stylizeNoColor(str, styleType) {
              return str;
            }
            function arrayToHash(array) {
              var hash = {};
              array.forEach(function(val, idx) {
                hash[val] = true;
              });
              return hash;
            }
            function formatValue(ctx, value, recurseTimes) {
              if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports2.inspect && !(value.constructor && value.constructor.prototype === value)) {
                var ret = value.inspect(recurseTimes, ctx);
                if (!isString(ret)) {
                  ret = formatValue(ctx, ret, recurseTimes);
                }
                return ret;
              }
              var primitive = formatPrimitive(ctx, value);
              if (primitive) {
                return primitive;
              }
              var keys = Object.keys(value);
              var visibleKeys = arrayToHash(keys);
              if (ctx.showHidden) {
                keys = Object.getOwnPropertyNames(value);
              }
              if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
                return formatError(value);
              }
              if (keys.length === 0) {
                if (isFunction(value)) {
                  var name = value.name ? ": " + value.name : "";
                  return ctx.stylize("[Function" + name + "]", "special");
                }
                if (isRegExp(value)) {
                  return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                }
                if (isDate(value)) {
                  return ctx.stylize(Date.prototype.toString.call(value), "date");
                }
                if (isError(value)) {
                  return formatError(value);
                }
              }
              var base = "", array = false, braces = ["{", "}"];
              if (isArray(value)) {
                array = true;
                braces = ["[", "]"];
              }
              if (isFunction(value)) {
                var n = value.name ? ": " + value.name : "";
                base = " [Function" + n + "]";
              }
              if (isRegExp(value)) {
                base = " " + RegExp.prototype.toString.call(value);
              }
              if (isDate(value)) {
                base = " " + Date.prototype.toUTCString.call(value);
              }
              if (isError(value)) {
                base = " " + formatError(value);
              }
              if (keys.length === 0 && (!array || value.length == 0)) {
                return braces[0] + base + braces[1];
              }
              if (recurseTimes < 0) {
                if (isRegExp(value)) {
                  return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                } else {
                  return ctx.stylize("[Object]", "special");
                }
              }
              ctx.seen.push(value);
              var output;
              if (array) {
                output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
              } else {
                output = keys.map(function(key) {
                  return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                });
              }
              ctx.seen.pop();
              return reduceToSingleString(output, base, braces);
            }
            function formatPrimitive(ctx, value) {
              if (isUndefined(value))
                return ctx.stylize("undefined", "undefined");
              if (isString(value)) {
                var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                return ctx.stylize(simple, "string");
              }
              if (isNumber(value))
                return ctx.stylize("" + value, "number");
              if (isBoolean(value))
                return ctx.stylize("" + value, "boolean");
              if (isNull(value))
                return ctx.stylize("null", "null");
            }
            function formatError(value) {
              return "[" + Error.prototype.toString.call(value) + "]";
            }
            function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
              var output = [];
              for (var i = 0, l = value.length; i < l; ++i) {
                if (hasOwnProperty(value, String(i))) {
                  output.push(formatProperty(
                    ctx,
                    value,
                    recurseTimes,
                    visibleKeys,
                    String(i),
                    true
                  ));
                } else {
                  output.push("");
                }
              }
              keys.forEach(function(key) {
                if (!key.match(/^\d+$/)) {
                  output.push(formatProperty(
                    ctx,
                    value,
                    recurseTimes,
                    visibleKeys,
                    key,
                    true
                  ));
                }
              });
              return output;
            }
            function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
              var name, str, desc;
              desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
              if (desc.get) {
                if (desc.set) {
                  str = ctx.stylize("[Getter/Setter]", "special");
                } else {
                  str = ctx.stylize("[Getter]", "special");
                }
              } else {
                if (desc.set) {
                  str = ctx.stylize("[Setter]", "special");
                }
              }
              if (!hasOwnProperty(visibleKeys, key)) {
                name = "[" + key + "]";
              }
              if (!str) {
                if (ctx.seen.indexOf(desc.value) < 0) {
                  if (isNull(recurseTimes)) {
                    str = formatValue(ctx, desc.value, null);
                  } else {
                    str = formatValue(ctx, desc.value, recurseTimes - 1);
                  }
                  if (str.indexOf("\n") > -1) {
                    if (array) {
                      str = str.split("\n").map(function(line) {
                        return "  " + line;
                      }).join("\n").substr(2);
                    } else {
                      str = "\n" + str.split("\n").map(function(line) {
                        return "   " + line;
                      }).join("\n");
                    }
                  }
                } else {
                  str = ctx.stylize("[Circular]", "special");
                }
              }
              if (isUndefined(name)) {
                if (array && key.match(/^\d+$/)) {
                  return str;
                }
                name = JSON.stringify("" + key);
                if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                  name = name.substr(1, name.length - 2);
                  name = ctx.stylize(name, "name");
                } else {
                  name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                  name = ctx.stylize(name, "string");
                }
              }
              return name + ": " + str;
            }
            function reduceToSingleString(output, base, braces) {
              var numLinesEst = 0;
              var length = output.reduce(function(prev, cur) {
                numLinesEst++;
                if (cur.indexOf("\n") >= 0)
                  numLinesEst++;
                return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
              }, 0);
              if (length > 60) {
                return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
              }
              return braces[0] + base + " " + output.join(", ") + " " + braces[1];
            }
            function isArray(ar) {
              return Array.isArray(ar);
            }
            exports2.isArray = isArray;
            function isBoolean(arg) {
              return typeof arg === "boolean";
            }
            exports2.isBoolean = isBoolean;
            function isNull(arg) {
              return arg === null;
            }
            exports2.isNull = isNull;
            function isNullOrUndefined(arg) {
              return arg == null;
            }
            exports2.isNullOrUndefined = isNullOrUndefined;
            function isNumber(arg) {
              return typeof arg === "number";
            }
            exports2.isNumber = isNumber;
            function isString(arg) {
              return typeof arg === "string";
            }
            exports2.isString = isString;
            function isSymbol(arg) {
              return typeof arg === "symbol";
            }
            exports2.isSymbol = isSymbol;
            function isUndefined(arg) {
              return arg === void 0;
            }
            exports2.isUndefined = isUndefined;
            function isRegExp(re) {
              return isObject(re) && objectToString(re) === "[object RegExp]";
            }
            exports2.isRegExp = isRegExp;
            function isObject(arg) {
              return typeof arg === "object" && arg !== null;
            }
            exports2.isObject = isObject;
            function isDate(d) {
              return isObject(d) && objectToString(d) === "[object Date]";
            }
            exports2.isDate = isDate;
            function isError(e) {
              return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
            }
            exports2.isError = isError;
            function isFunction(arg) {
              return typeof arg === "function";
            }
            exports2.isFunction = isFunction;
            function isPrimitive(arg) {
              return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
            }
            exports2.isPrimitive = isPrimitive;
            exports2.isBuffer = __webpack_require__(25);
            function objectToString(o) {
              return Object.prototype.toString.call(o);
            }
            function pad(n) {
              return n < 10 ? "0" + n.toString(10) : n.toString(10);
            }
            var months = [
              "Jan",
              "Feb",
              "Mar",
              "Apr",
              "May",
              "Jun",
              "Jul",
              "Aug",
              "Sep",
              "Oct",
              "Nov",
              "Dec"
            ];
            function timestamp() {
              var d = new Date();
              var time = [
                pad(d.getHours()),
                pad(d.getMinutes()),
                pad(d.getSeconds())
              ].join(":");
              return [d.getDate(), months[d.getMonth()], time].join(" ");
            }
            exports2.log = function() {
              console.log("%s - %s", timestamp(), exports2.format.apply(exports2, arguments));
            };
            exports2.inherits = __webpack_require__(26);
            exports2._extend = function(origin, add) {
              if (!add || !isObject(add))
                return origin;
              var keys = Object.keys(add);
              var i = keys.length;
              while (i--) {
                origin[keys[i]] = add[keys[i]];
              }
              return origin;
            };
            function hasOwnProperty(obj, prop) {
              return Object.prototype.hasOwnProperty.call(obj, prop);
            }
          }).call(exports2, function() {
            return this;
          }(), __webpack_require__(24));
        },
        function(module2, exports2) {
          var process = module2.exports = {};
          var cachedSetTimeout;
          var cachedClearTimeout;
          function defaultSetTimout() {
            throw new Error("setTimeout has not been defined");
          }
          function defaultClearTimeout() {
            throw new Error("clearTimeout has not been defined");
          }
          (function() {
            try {
              if (typeof setTimeout === "function") {
                cachedSetTimeout = setTimeout;
              } else {
                cachedSetTimeout = defaultSetTimout;
              }
            } catch (e) {
              cachedSetTimeout = defaultSetTimout;
            }
            try {
              if (typeof clearTimeout === "function") {
                cachedClearTimeout = clearTimeout;
              } else {
                cachedClearTimeout = defaultClearTimeout;
              }
            } catch (e) {
              cachedClearTimeout = defaultClearTimeout;
            }
          })();
          function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) {
              return setTimeout(fun, 0);
            }
            if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
              cachedSetTimeout = setTimeout;
              return setTimeout(fun, 0);
            }
            try {
              return cachedSetTimeout(fun, 0);
            } catch (e) {
              try {
                return cachedSetTimeout.call(null, fun, 0);
              } catch (e2) {
                return cachedSetTimeout.call(this, fun, 0);
              }
            }
          }
          function runClearTimeout(marker) {
            if (cachedClearTimeout === clearTimeout) {
              return clearTimeout(marker);
            }
            if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
              cachedClearTimeout = clearTimeout;
              return clearTimeout(marker);
            }
            try {
              return cachedClearTimeout(marker);
            } catch (e) {
              try {
                return cachedClearTimeout.call(null, marker);
              } catch (e2) {
                return cachedClearTimeout.call(this, marker);
              }
            }
          }
          var queue = [];
          var draining = false;
          var currentQueue;
          var queueIndex = -1;
          function cleanUpNextTick() {
            if (!draining || !currentQueue) {
              return;
            }
            draining = false;
            if (currentQueue.length) {
              queue = currentQueue.concat(queue);
            } else {
              queueIndex = -1;
            }
            if (queue.length) {
              drainQueue();
            }
          }
          function drainQueue() {
            if (draining) {
              return;
            }
            var timeout = runTimeout(cleanUpNextTick);
            draining = true;
            var len = queue.length;
            while (len) {
              currentQueue = queue;
              queue = [];
              while (++queueIndex < len) {
                if (currentQueue) {
                  currentQueue[queueIndex].run();
                }
              }
              queueIndex = -1;
              len = queue.length;
            }
            currentQueue = null;
            draining = false;
            runClearTimeout(timeout);
          }
          process.nextTick = function(fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1) {
              for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
              }
            }
            queue.push(new Item(fun, args));
            if (queue.length === 1 && !draining) {
              runTimeout(drainQueue);
            }
          };
          function Item(fun, array) {
            this.fun = fun;
            this.array = array;
          }
          Item.prototype.run = function() {
            this.fun.apply(null, this.array);
          };
          process.title = "browser";
          process.browser = true;
          process.env = {};
          process.argv = [];
          process.version = "";
          process.versions = {};
          function noop() {
          }
          process.on = noop;
          process.addListener = noop;
          process.once = noop;
          process.off = noop;
          process.removeListener = noop;
          process.removeAllListeners = noop;
          process.emit = noop;
          process.prependListener = noop;
          process.prependOnceListener = noop;
          process.listeners = function(name) {
            return [];
          };
          process.binding = function(name) {
            throw new Error("process.binding is not supported");
          };
          process.cwd = function() {
            return "/";
          };
          process.chdir = function(dir) {
            throw new Error("process.chdir is not supported");
          };
          process.umask = function() {
            return 0;
          };
        },
        function(module2, exports2) {
          module2.exports = function isBuffer(arg) {
            return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
          };
        },
        function(module2, exports2) {
          if (typeof Object.create === "function") {
            module2.exports = function inherits(ctor, superCtor) {
              ctor.super_ = superCtor;
              ctor.prototype = Object.create(superCtor.prototype, {
                constructor: {
                  value: ctor,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
            };
          } else {
            module2.exports = function inherits(ctor, superCtor) {
              ctor.super_ = superCtor;
              var TempCtor = function() {
              };
              TempCtor.prototype = superCtor.prototype;
              ctor.prototype = new TempCtor();
              ctor.prototype.constructor = ctor;
            };
          }
        },
        function(module2, exports2, __webpack_require__) {
          var DOM = __webpack_require__(9);
          var utils = __webpack_require__(7);
          module2.exports = function() {
            var canvas = DOM.newEl("canvas");
            var ctx = null;
            return function(sceneGraph) {
              if (ctx == null) {
                ctx = canvas.getContext("2d");
              }
              var dpr = utils.canvasRatio();
              var root = sceneGraph.root;
              canvas.width = dpr * root.properties.width;
              canvas.height = dpr * root.properties.height;
              ctx.textBaseline = "middle";
              var bg = root.children.holderBg;
              var bgWidth = dpr * bg.width;
              var bgHeight = dpr * bg.height;
              var outlineWidth = 2;
              var outlineOffsetWidth = outlineWidth / 2;
              ctx.fillStyle = bg.properties.fill;
              ctx.fillRect(0, 0, bgWidth, bgHeight);
              if (bg.properties.outline) {
                ctx.strokeStyle = bg.properties.outline.fill;
                ctx.lineWidth = bg.properties.outline.width;
                ctx.moveTo(outlineOffsetWidth, outlineOffsetWidth);
                ctx.lineTo(bgWidth - outlineOffsetWidth, outlineOffsetWidth);
                ctx.lineTo(bgWidth - outlineOffsetWidth, bgHeight - outlineOffsetWidth);
                ctx.lineTo(outlineOffsetWidth, bgHeight - outlineOffsetWidth);
                ctx.lineTo(outlineOffsetWidth, outlineOffsetWidth);
                ctx.moveTo(0, outlineOffsetWidth);
                ctx.lineTo(bgWidth, bgHeight - outlineOffsetWidth);
                ctx.moveTo(0, bgHeight - outlineOffsetWidth);
                ctx.lineTo(bgWidth, outlineOffsetWidth);
                ctx.stroke();
              }
              var textGroup = root.children.holderTextGroup;
              ctx.font = textGroup.properties.font.weight + " " + dpr * textGroup.properties.font.size + textGroup.properties.font.units + " " + textGroup.properties.font.family + ", monospace";
              ctx.fillStyle = textGroup.properties.fill;
              for (var lineKey in textGroup.children) {
                var line = textGroup.children[lineKey];
                for (var wordKey in line.children) {
                  var word = line.children[wordKey];
                  var x = dpr * (textGroup.x + line.x + word.x);
                  var y = dpr * (textGroup.y + line.y + word.y + textGroup.properties.leading / 2);
                  ctx.fillText(word.properties.text, x, y);
                }
              }
              return canvas.toDataURL("image/png");
            };
          }();
        }
      ]);
    });
    (function(ctx, isMeteorPackage) {
      if (isMeteorPackage) {
        Holder = ctx.Holder;
      }
    })(exports, typeof Meteor !== "undefined" && typeof Package !== "undefined");
  }
});

// dep:holderjs
var holderjs_default = require_holder();
export {
  holderjs_default as default
};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/*!

Holder - client side image placeholders
Version 2.9.9+jl7z
 2021 Ivan Malopinsky - https://imsky.co

Site:     http://holderjs.com
Issues:   https://github.com/imsky/holder/issues
License:  MIT

*/
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/*!
 * onDomReady.js 1.4.0 (c) 2013 Tubal Martin - MIT license
 *
 * Specially modified to work with Holder.js
 */
// @license http://opensource.org/licenses/MIT
//# sourceMappingURL=holderjs.js.map
